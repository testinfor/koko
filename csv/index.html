<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>KOKO CSV コンバーター（Web）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- PapaParse: CSVパーサ（ストリーミング対応） -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" defer></script>
  <style>
    :root { --bg:#0f172a; --fg:#e2e8f0; --muted:#94a3b8; --accent:#22d3ee; --ring:#22d3ee55; }
    html,body { height: 100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif; background:var(--bg); color:var(--fg); }
    .wrap { max-width: 920px; margin: 0 auto; padding: 32px 16px 64px; }
    h1 { font-size: 22px; font-weight: 700; margin: 0 0 12px; letter-spacing: .3px; }
    p { color: var(--muted); margin: 6px 0 20px; }
    .panel { display:flex; gap:16px; flex-wrap:wrap; align-items: center; }
    .drop {
      flex:1 1 540px; min-height: 220px; border: 2px dashed #334155; border-radius: 12px;
      display:grid; place-items:center; text-align:center; padding: 18px; transition: .15s ease;
      background: #0b1220;
    }
    .drop.drag { border-color: var(--accent); box-shadow: 0 0 0 6px var(--ring); transform: translateY(-1px); }
    .btn { appearance: none; border:1px solid #334155; background:#0b1220; color:var(--fg);
      padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; }
    .btn:hover { border-color:#475569; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    select { background:#0b1220; border:1px solid #334155; color:var(--fg); border-radius:10px; padding:10px 12px; }
    .log {
      margin-top: 16px; padding: 12px; background: #0b1220; border:1px solid #334155; border-radius: 10px;
      max-height: 260px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;
    }
    a.inline { color: var(--accent); text-decoration: none; }
    .hint { font-size: 12px; color: var(--muted); }
    code { color:#cbd5e1; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>KOKO CSV コンバーター（Web）</h1>
    <p>CSV をドロップ／選択すると、<code>settings.json</code> のルールに従って複数の CSV に分割し、すぐにダウンロードします。<br></p>

    <div class="panel">
      <div id="drop" class="drop" role="region" aria-label="CSVドロップ領域">
        <div>
          <div style="font-size:18px;font-weight:700;margin-bottom:6px">ここに CSV ファイルをドロップ</div>
          <div class="hint">または右側のボタンで選択</div>
        </div>
      </div>

      <div style="display:flex;flex-direction:column;gap:12px;min-width:280px">
        <div class="row">
          <button id="pick" class="btn" type="button">CSV ファイルを選択</button>
          <input id="file" type="file" accept=".csv,text/csv" hidden multiple />
        </div>

        <div class="row">
          <label class="hint" for="enc">入力エンコーディング</label>
          <select id="enc" aria-label="入力エンコーディング">
            <option value="utf-8" selected>UTF-8（既定）</option>
            <option value="shift_jis">Shift_JIS（MS932）</option>
            <option value="euc-jp">EUC-JP</option>
          </select>
        </div>

        <div class="row">
          <label class="hint" for="delim">区切り文字</label>
          <select id="delim" aria-label="区切り文字">
            <option value="auto" selected>自動検出</option>
            <option value=",">カンマ (,)</option>
            <option value=";">セミコロン (;)</option>
            <option value="	">タブ (\\t)</option>
            <option value="|">パイプ (|)</option>
          </select>
        </div>

        <div class="hint">設定ファイル：<code><a class="inline" href="settings.json" target="_blank" rel="noopener">settings.json</a></code>（リポジトリ直下）</div>
      </div>
    </div>

    <div id="log" class="log" aria-live="polite"></div>
  </div>

<script>
/* ======================= 小さなユーティリティ ======================= */

const logBox = document.getElementById('log');
function logLine(...args) {
  const s = args.map(x => typeof x === 'string' ? x : JSON.stringify(x)).join(' ');
  const line = document.createElement('div');
  line.textContent = s;
  logBox.appendChild(line);
  logBox.scrollTop = logBox.scrollHeight;
}

function fileBaseName(name) {
  const low = name.toLowerCase();
  const i = low.lastIndexOf('.csv');
  return i >= 0 ? name.substring(0, i) : name;
}

// ヘッダーキーの正規化：trim + 先頭BOM除去 + NBSP→space
function normalizeHeaderKey(s) {
  if (s == null) return s;
  let t = String(s).trim();
  if (t.length && t.charCodeAt(0) === 0xFEFF) t = t.substring(1);
  t = t.replace(/\u00A0/g, ' ');
  return t;
}

// CSVフィールドのエスケープ（RFC4180系）
function csvEscape(v) {
  const s = v == null ? '' : String(v).trim();
  if (/[",\r\n]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
  return s;
}

// ダウンロード開始
function downloadText(filename, text) {
  const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'), { href: url, download: filename });
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 0);
}

// 「通常文字列の全置換」（正規表現ではなく素直な split/join）
function replaceAllPlain(s, before, after) {
  if (!before) return s;
  return String(s).split(before).join(after);
}

/* ======================= settings.json ローダ ======================= */

let FILESPLIT = [];    // [{ prefix, column: [...] }, ...]
let RENAME_RULES = []; // [{ column:[...], before, after }, ...]

async function loadSettings() {
  const res = await fetch('settings.json', { cache: 'no-cache' });
  if (!res.ok) throw new Error(`settings.json の読み込みに失敗しました: ${res.status}`);
  const js = await res.json();

  if (Array.isArray(js)) {
    // 旧スキーマ：配列＝filesplit
    FILESPLIT = js;
    RENAME_RULES = [];
  } else {
    FILESPLIT = Array.isArray(js?.filesplit) ? js.filesplit : [];
    RENAME_RULES = Array.isArray(js?.rename) ? js.rename : [];
  }
  if (!Array.isArray(FILESPLIT)) throw new Error('settings: filesplit が不正です');
  if (!Array.isArray(RENAME_RULES)) throw new Error('settings: rename が不正です');

  logLine(`設定を読み込みました：filesplit=${FILESPLIT.length}, rename=${RENAME_RULES.length}`);
}

/* ======================= 変換エンジン ======================= */

class ActiveConv {
  constructor(prefix, indexes, headerNames, outName, transformsByIndex) {
    this.prefix = prefix;
    this.indexes = indexes;
    this.headerNames = headerNames; // 出力ヘッダー名（設定そのまま）
    this.outName = outName;
    this.transformsByIndex = transformsByIndex; // Map<number, Array<{before, after}>>
    // 先頭に BOM を付与し、CRLF 固定で Excel 互換
    this.parts = ['\uFEFF' + headerNames.map(csvEscape).join(',') + '\r\n'];
    this.rows = 0;
  }
  pushRow(srcRow) {
    const row = this.indexes.map(i => {
      let v = i < srcRow.length ? srcRow[i] : '';
      const ts = this.transformsByIndex.get(i);
      if (ts && ts.length) {
        for (const t of ts) v = replaceAllPlain(v, t.before, t.after);
      }
      return csvEscape(String(v).trim());
    }).join(',');
    this.parts.push(row + '\r\n');
    this.rows++;
  }
  finalize() { return this.parts.join(''); }
}

/**
 * ファイル1つを処理：
 *  - TextDecoder で文字コードを適用
 *  - 区切り文字は自動検出（必要なら手動指定）
 *  - 先頭行をヘッダーとして扱い、正規化キーでマッチング
 *  - rename ルール（列ごとの文字列置換）を適用した上で filesplit に従って同時書き出し
 */
async function processOneFile(file, { encoding = 'utf-8', delimiter = 'auto' } = {}) {
  logLine(`----- ${file.name} -----`);
  const base = fileBaseName(file.name);

  // 入力を選択エンコーディングで文字列化
  const buf = await file.arrayBuffer();
  const decoder = new TextDecoder(encoding);
  const text = decoder.decode(buf);

  return new Promise((resolve, reject) => {
    let header = null;                   // 元ヘッダー配列
    let normHeaderMap = new Map();       // 正規化キー -> 最初のインデックス
    let actives = [];                    // 有効な変換ジョブ

    Papa.parse(text, {
      worker: true,
      skipEmptyLines: 'greedy',
      delimiter: delimiter === 'auto' ? '' : delimiter,
      header: false, // 配列として受け取り、先頭行を自前でヘッダー扱い
      step: (results, parser) => {
        const row = results.data;

        // ヘッダー初期化
        if (header === null) {
          header = row.map(c => c);
          header.forEach((h, idx) => {
            const k = normalizeHeaderKey(h);
            if (!normHeaderMap.has(k)) normHeaderMap.set(k, idx); // 重複は先勝ち
          });
          logLine('正規化済みヘッダー:', Object.fromEntries(normHeaderMap));

          // rename ルールを「列インデックス→置換リスト」に展開
          const transformsByIndex = new Map();
          for (const r of RENAME_RULES) {
            if (!r || !Array.isArray(r.column)) continue;
            const before = 'before' in r ? String(r.before) : undefined;
            const after  = 'after'  in r ? String(r.after)  : undefined;
            if (typeof before !== 'string' || typeof after !== 'string' || before === '') continue;

            for (const col of r.column) {
              const idx = normHeaderMap.get(normalizeHeaderKey(col));
              if (Number.isInteger(idx)) {
                if (!transformsByIndex.has(idx)) transformsByIndex.set(idx, []);
                transformsByIndex.get(idx).push({ before, after }); // 設定順に適用
              }
            }
          }

          // filesplit から出力ジョブを構築
          actives = [];
          for (const c of FILESPLIT) {
            if (!c || !c.prefix || !Array.isArray(c.column)) continue;
            const idxs = [];
            const names = [];
            for (const col of c.column) {
              const idx = normHeaderMap.get(normalizeHeaderKey(col));
              if (Number.isInteger(idx)) { idxs.push(idx); names.push(col); }
            }
            if (idxs.length > 0) {
              const outName = `${base}_${c.prefix}.csv`;
              actives.push(new ActiveConv(c.prefix, idxs, names, outName, transformsByIndex));
            }
          }

          if (actives.length === 0) {
            parser.abort();
            reject(new Error('有効な変換ルールが見つかりません（settings の列名と一致するものがありません）'));
          }
          return; // 次行からデータ
        }

        // データ行：全ジョブに同時書き込み（rename 置換は ActiveConv 内で実施）
        for (const ac of actives) ac.pushRow(row);
      },
      complete: () => {
        for (const ac of actives) {
          const content = ac.finalize();
          downloadText(ac.outName, content);
          logLine(`出力: ${ac.outName}（${ac.rows} 行）`);
        }
        resolve();
      },
      error: (err) => reject(err)
    });
  });
}

/* ======================= UI バインド ======================= */

(async function init() {
  try { await loadSettings(); }
  catch (e) { logLine(String(e)); }

  const drop = document.getElementById('drop');
  const input = document.getElementById('file');
  const pick = document.getElementById('pick');
  const encSel = document.getElementById('enc');
  const delimSel = document.getElementById('delim');

  ['dragenter','dragover'].forEach(t => drop.addEventListener(t, e => {
    e.preventDefault(); e.stopPropagation(); drop.classList.add('drag');
  }));
  ['dragleave','drop'].forEach(t => drop.addEventListener(t, e => {
    e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag');
  }));

  drop.addEventListener('drop', async e => {
    const files = [...(e.dataTransfer?.files || [])]
      .filter(f => f.type.includes('csv') || f.name.toLowerCase().endsWith('.csv'));
    if (files.length === 0) { logLine('CSV ファイルが見つかりません'); return; }
    for (const f of files) {
      try {
        await processOneFile(f, { encoding: encSel.value, delimiter: delimSel.value });
        logLine('完了');
      } catch (err) {
        logLine('エラー:', err.message || String(err));
      }
    }
  });

  pick.addEventListener('click', () => input.click());
  input.addEventListener('change', async () => {
    const files = [...input.files];
    input.value = ''; // 同じファイルを再選択可能に
    for (const f of files) {
      try {
        await processOneFile(f, { encoding: encSel.value, delimiter: delimSel.value });
        logLine('完了');
      } catch (err) {
        logLine('エラー:', err.message || String(err));
      }
    }
  });
})();
</script>
</body>
</html>
